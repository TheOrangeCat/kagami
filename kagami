#!/bin/bash
#
# kagami - Small and simple package manager for Ataraxia Linux
#

set -x

umask 022

CMD="$1"
ARG="$2"

export LC_ALL="C"
export VERSION="20190415"
export DB="/var/lib/kagami"
export PKGS="$DB/pkgs"
export HOOKS="$DB/hooks"

if [ -z "$CONF" ]; then
	CONF="/etc/kagami.conf"
fi

source $CONF

msg() {
	local msg=$(echo $1 | tr -s / /)
	printf "\e[1m\e[32m==>\e[0m $msg\n"
}

die() {
	local msg=$(echo $1 | tr -s / /)
	printf "\e[1m\e[31m==!\e[0m $msg\n"
	rm -rf "$temp"
	exit 1
}

# from old apk-tools
list_subtract() {
	(
		# first we find all uniq lines
		cat "$1" "$2" | sort | uniq -u

		# then we combine uniq lines with first file ...
		cat "$1"

		# ...and find all duplicates. Those only exist in first file
	) | sort | uniq -d
}

# this stuff too
list_uninstall() {
	local f p
	local files=$(sort -r "$1" | sed 's:^:'"$root"': ; s:/^[^\.]\./::g; s:/\{2,\}:/:g; s:/\./:/:g')
	if [ -z "$DRYRUN" ] ; then
		echo "$files" | tr '\n' '\0' | xargs -0 rm 2>/dev/null
		echo "$files" | tr '\n' '\0' | xargs -0 rmdir 2>/dev/null
		[ "$2" ] && echo "$files" >> "$2"
	fi
	return 0
}

pkgadd() {
	local pkg apkg bpkg cpkg dpkg root temp toremove req a myhooks name version release backup abackup UPDATE

	pkg="$1"
	root="$2"
	temp="$(mktemp -d)" || die "kagami: couldn't create a temporary directory"

	[ -f "$pkg" ] || die "kagami: file not found or not specified"
	[ -z "${pkg##*.bepsu}" ] || die "kagami: your package extension is not supported"

	apkg="$(basename $pkg)"
	bpkg="${apkg%*.bepsu}"
	cpkg="${bpkg%-*}"
	dpkg="${cpkg%#*}"

	if [ -d "$root"/$PKGS/$dpkg ]; then
		UPDATE=1
	else
		UPDATE=0
	fi

	if [ "$UPDATE" = "1" ]; then
		msg "Upgrading $dpkg"
	else
		msg "Installing $dpkg"
	fi

	rm -rf "$root"/bepsu

	tar tf "$pkg" >/dev/null || die "kagami: can't extract package archive. check if archive is broken"

	tar -xf "$pkg" -C "$temp"

	for req in manifest filelist; do
		if [ ! -f "$temp"/bepsu/$req ]; then
			die "kagami: couldn't find '"$req"' file"
		fi
	done

	source "$temp"/bepsu/manifest

	if [ "$NO_BACKUP" != "1" ]; then
		if [ -n "$backup" ]; then
			for abackup in ${backup[@]}; do
				if [ -f "$root"/$abackup ]; then
					mv "$root"/$abackup "$root"/$abackup.bak
				fi
			done
		fi
	fi

	if [ "$UPDATE" = "1" ]; then
		cp "$root"/$PKGS/$dpkg/filelist "$temp"/filelist.old
	fi

	if [ ! -d "$root"/$PKGS/$dpkg ]; then
		mkdir -p "$root"/$PKGS/$dpkg || die "kagami: couldn't write package in database"
	fi

	for req in manifest filelist; do
		cp "$temp"/bepsu/$req "$root"/$PKGS/$dpkg/$req || die "kagami: failed to copy required files"
	done

	for req in pre-{install,update,remove} post-{install,update,remove}; do
		if [ -f "$temp"/bepsu/$req ]; then
			cp "$temp"/bepsu/$req "$root"/$PKGS/$dpkg/$req
		fi
	done

	if [ "$RUN_SCRIPTS" = "1" ]; then
		if [ "$UPDATE" = "1" ]; then
			if [ -f "$root"$PKGS/$dpkg/pre-update ]; then
				chroot "$root"/ /bin/bash $PKGS/$dpkg/pre-update || true
			fi
		else
			if [ -f "$root"$PKGS/$dpkg/pre-install ]; then
				chroot "$root"/ /bin/bash $PKGS/$dpkg/pre-install || true
			fi
		fi
	fi

	tar -xf "$pkg" -C "$root"/ && rm -rf "$root"/bepsu

	if [ "$UPDATE" = "1" ]; then
		list_subtract "$temp"/filelist.old "$temp"/bepsu/filelist | list_uninstall -
	fi

	if [ "$NO_BACKUP" != "1" ]; then
		if [ -n "$backup" ]; then
			for abackup in ${backup[@]}; do
				if [ -f "$root"/$abackup ]; then
					rm -rf "$root"/$abackup
					mv "$root"/$abackup.bak "$root"/$abackup
				fi
			done
		fi
	fi

	if [ "$RUN_SCRIPTS" = "1" ]; then
		if [ "$UPDATE" = "1" ]; then
			if [ -f "$root"$PKGS/$dpkg/post-update ]; then
				chroot "$root"/ /bin/bash $PKGS/$dpkg/post-update || true
			fi
		else
			if [ -f "$root"$PKGS/$dpkg/post-install ]; then
				chroot "$root"/ /bin/bash $PKGS/$dpkg/post-install || true
			fi
		fi
	fi

	if [ "$RUN_HOOKS" = "1" ]; then
		for myhooks in $(ls "$root"$HOOKS/ | sort); do
			chroot "$root"/ /bin/bash $HOOKS/$myhooks
		done
	fi

	rm -rf "$temp"
}

pkgrm() {
	local dpkg root myhooks name version release backup abackup nondir dirlist

	dpkg="$1"
	root="$2"

	#[ -z "$dpkg" ] || die "kagami: package name not specified"

	if [ ! -d "$root"/$PKGS/$dpkg ]; then
		die "kagami: package not installed"
	fi

	msg "Removing $dpkg"
	source "$root"/$PKGS/$dpkg/manifest

	if [ "$NO_BACKUP" != "1" ]; then
		if [ -n "$backup" ]; then
			for abackup in ${backup[@]}; do
				if [ -f "$root"/$abackup ]; then
					mv "$root"/$abackup "$root"/$abackup.bak
				fi
			done
		fi
	fi

	if [ "$RUN_SCRIPTS" = "1" ]; then
		if [ -f "$root"$PKGS/$dpkg/pre-remove ]; then
			chroot "$root"/ /bin/bash $PKGS/$dpkg/pre-install || true
		fi
	fi

	dirlist=`grep '/$' "$root"/$PKGS/$dpkg/filelist`
	nondir=`grep -v '/$' "$root"/$PKGS/$dpkg/filelist`
	list_uninstall "$root"/$PKGS/$dpkg/filelist
	rm -rf "$root"/$PKGS/$dpkg

	[ -e /usr/bin/sh ] || ln -sf /usr/bin/busybox /usr/bin/sh

	if [ "$NO_BACKUP" != "1" ]; then
		if [ -n "$backup" ]; then
			for abackup in ${backup[@]}; do
				if [ -f "$root"/$abackup ]; then
					mv "$root"/$abackup.bak "$root"/$abackup
				fi
			done
		fi
	fi

	if [ "$RUN_SCRIPTS" = "1" ]; then
		if [ -f "$root"$PKGS/$dpkg/post-remove ]; then
			chroot "$root"/ /bin/bash $PKGS/$dpkg/pre-install || true
		fi
	fi

	if [ "$RUN_HOOKS" = "1" ]; then
		for myhooks in $(ls "$root"$HOOKS/ | sort); do
			chroot "$root"/ /bin/bash $HOOKS/$myhooks
		done
	fi
}

pkgrm $1 $2

exit 0

